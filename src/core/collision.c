#include <core/collision.h>
#include <math.h>

int anypoints(SoftBody A, SoftBody B) {
        // ? Idea: optimize this through slice-subdivision
        for (int i = 0; i < A.numPoints; i++) {
                Vector2 point = A.pointPos[i];
                for (int surf = 0; surf < B.numSurfaces; surf++) {
                        Vector2 p1 = B.pointPos[B.surfaceA[surf]];
                        Vector2 p2 = B.pointPos[B.surfaceB[surf]];

                        float dy = p2.y - p1.y;
                        if (dy < 0)
                                continue; // Point would be outside of polygon anyways

                        float min = fminf(p1.y, p2.y);
                        float max = fmaxf(p1.y, p2.y);

                        if (point.y < min || point.y > max)
                                continue; // Line isn't on the same axis as the point
                        float dx = p2.x - p1.x;
                        float cross = (point.x - p1.x) * dy - dx * (point.y - p1.y);

                        if (cross > 0)
                                continue;

                        return i;
                }
        }
        return -1;
}

void nearestSurface(SoftBody A, int a_i, SoftBody B, int *nearestSurf, float *nearestDist, float *t, Vector2 *nearestPoint) {
        Vector2 point = A.pointPos[a_i];

        *nearestDist = FP_PINF;
        for (int surf = 0; surf < B.numSurfaces; surf++) {
                Vector2 p1 = B.pointPos[B.surfaceA[surf]];
                Vector2 p2 = B.pointPos[B.surfaceB[surf]];

                Vector2 diff = Vector2Subtract(p2, p1);

                float l2 = Vector2LengthSqr(diff);
                Vector2 projection;
                // Since we're assuming a closed polygon, we can actually
                // make some assumptions. We don't ever need to clamp,
                // we can just continue, because since it's inside a polygon,
                // we know that it always is closest to an actual point on the segments
                if (l2 == 0.0)
                        continue;

                float t = Vector2DotProduct(Vector2Subtract(point, p1), diff) / l2;

                if (t < 0.f || t > 1.f)
                        continue;

                projection = Vector2Add(p1, Vector2Scale(diff, t)); // Projection falls on the segment

                float dist = Vector2Distance(point, projection);
                if (dist < *nearestDist) {
                        *nearestSurf = surf;
                        *nearestPoint = projection;
                        *nearestDist = dist;
                }
        }
}

CollisionData _internalCheckCollision(SoftBody A, SoftBody B) {
        int p = anypoints(A, B);
        if (p == -1) {
                return (CollisionData){.collided = false};
        }

        CollisionData data = (CollisionData){.invert = false, .collided = true, .point = p};
        nearestSurface(A, p, B, &data.edge, &data.distance, &data.edge_t, &data.nearest);

        return data;
}

CollisionData checkCollision(SoftBody A, SoftBody B) {
        // Top-down refinement
        // First we devise an algorithm for detecing collision
        // and effeciently finding the colliding points

        // Check bounding boxes
        if (
            A.bounds.max.x < B.bounds.min.x ||
            A.bounds.max.y < B.bounds.min.y ||
            A.bounds.min.x > B.bounds.max.x ||
            A.bounds.min.y > B.bounds.max.y) {
                return (CollisionData){.collided = false};
        }

        CollisionData a = _internalCheckCollision(A, B);
        if (a.collided) {
                a = _internalCheckCollision(B, A);
                a.invert = true;
        }

        return a;
}

float getFriction(SoftBodyMaterial A, SoftBodyMaterial B) {
        // TODO: Actually populate this, maybe make it some compile-time autogenerated thing from a config file
        return 1.0;
}

// Assumes the collision is actually collided and already un-inverted
void handleCollision(SoftBody A, SoftBody B, CollisionData data, SoftBodyMaterial matA, SoftBodyMaterial matB, float dt) {
        float friction = getFriction(matA, matB);

        // Based on the ideas from JellyCar Worlds collision

        // First, shift the positions so the shapes are no longer intersecting

        // When solving for the math, I boiled down a solution into this:
        // Let...
        //   A and B be the points of the edge/surface,
        //   v be the point inside of it,
        //   u be the `edge_t`,
        //   m1 be the mass of points of the surface = `B.mass`
        //   m2 be the mass of the point inside = `A.mass`
        // Then...
        //   o = A + (B - A)u - v
        // The solution is given like so, where the subscript 1 is the new positions for the points:
        //   A1 = A - ao
        //   B1 = B - bo
        //   v1 = v + po
        // Where a, b, and p are now the unknowns we must solve for
        // We thus get these constraints:
        //   1) m1*a + m1*b - m2*p = 0  // Signifies the masses
        //   2) b/a = u/(1-u) // Signifies the "closeness" to either edge of the surface
        //   3) A1, B1, and v are colinear
        // It was *very* difficult to try to coax that last one into some linear equation, but I did, so
        // we can represent our solution very simply as the following augmented matrix:
        // [   m1     m1 -m2 |  0  ]
        // | u/(1-u) -1   0  |  0  |
        // [   1-u    u   1  |  1  ]
        // And thus we can solve using Cramer's rule (since in this case N=3 it's the best (I think))
        // In the code we rename A/B to p1/p2

        Vector2 p1 = B.pointPos[B.surfaceA[data.edge]],
                p2 = B.pointPos[B.surfaceB[data.edge]],
                v = A.pointPos[data.point];
        float u = data.edge_t, m1 = B.mass, m2 = A.mass;

        // o = p1 + (p2 - p1)*u - v;
        Vector2 o = Vector2Subtract(Vector2Add(p1, Vector2Scale(Vector2Subtract(p2, p1), u)), v);

        // Now for a very hacked-together Cramer's rule
        float ud1mu = u / (1 - u);
        float det = -m1 - (m1 * ud1mu) - m2 * (ud1mu * u + 1.f - u);

        float a = -m2 / det;         // det(M_1) very nicely simplifies
        float b = ud1mu * a;         // We find this directly from the second
        float p = (a + b) * m1 / m2; // And this directly from the first

        // And our solutions are:
        Vector2 A1 = Vector2Subtract(p1, Vector2Scale(o, a));
        Vector2 B1 = Vector2Subtract(p2, Vector2Scale(o, b));
        Vector2 v1 = Vector2Add(v, Vector2Scale(o, p));

        // Now resolve the velocities
        // Let's imagine combining the points A1 and B1 into a single point,
        // use the math for that to get the friction, impulse, e.t.c., and
        // then just split A1 and B1 back into two points
        // Make this new point be a weighted average of A1 and B1, again using u
        // Taking into account the friction and such
        // We basically again need to solve the equation 
}
